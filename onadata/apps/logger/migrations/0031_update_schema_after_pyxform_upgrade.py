# Generated by Django 5.1.8 on 2025-08-15 06:33


import json
import logging

from django.db import migrations

from pyxform.builder import create_survey_element_from_dict
from pyxform.errors import PyXFormError

# Handle optional pricing import
try:
    from pricing.exceptions import LimitExceededError
except ImportError:
    # Create a dummy exception class if pricing is not available
    class LimitExceededError(Exception):
        pass


SELECT_TYPES = ["select one", "select all that apply"]
CONTAINER_TYPES = ["group", "repeat"]
REQUIRED_FIELDS = ["name", "children"]


def ensure_choices_exist(data):
    """Ensure that the choices dictionary exists in the data."""
    if "choices" not in data:
        data["choices"] = {}
    return data["choices"]


def find_matching_choice_key(question_choices, choices):
    """Find a matching choice key for the given question choices."""
    # Create tuples of (name, label) for more precise matching
    question_choice_pairs = [
        (choice["name"], choice.get("label", "")) for choice in question_choices
    ]
    for choice_key, choice_list in choices.items():
        existing_choice_pairs = [
            (choice["name"], choice.get("label", "")) for choice in choice_list
        ]
        if question_choice_pairs == existing_choice_pairs:
            return choice_key
    return None


def process_select_question(child, choices):
    """Process a select question to add itemset attribute."""
    question_choices = child["children"]
    matching_key = find_matching_choice_key(question_choices, choices)
    if matching_key:
        # Use existing choice key
        child["itemset"] = matching_key
        logging.info(
            f"Question '{child['name']}' ({child['type']}) mapped to existing choice key '{matching_key}'"
        )
    else:
        # No matching choice found, add to choices using question name
        choices[child["name"]] = child["children"]
        child["itemset"] = child["name"]
        logging.info(
            f"Question '{child['name']}' ({child['type']}) added new choice key '{child['name']}'"
        )


def is_select_question_without_itemset(child):
    """Check if child is a select question without itemset."""
    return (
        child.get("type") in SELECT_TYPES
        and "children" in child
        and "itemset" not in child
    )


def is_container_with_children(child):
    """Check if child is a container (group/repeat) with children."""
    return child.get("type") in CONTAINER_TYPES and "children" in child


def process_children(children_list, choices):
    """Recursively process children to add itemset attributes"""
    for child in children_list:
        if is_select_question_without_itemset(child):
            process_select_question(child, choices)
        # Recursively process children in groups and repeats
        if is_container_with_children(child):
            process_children(child["children"], choices)


def update_xform_schema(apps, schema_editor):
    """Update the schema of all XForms after the PyXForm upgrade.

    This migration is necessary because the PyXForm upgrade introduced a bug
    that caused the schema of some XForms to be incorrect. This migration
    fixes the schema of all XForms after the PyXForm upgrade.
    """
    XForm = apps.get_model("logger", "XForm")
    processed = 0
    xform_qs = XForm.objects.filter(deleted_at__isnull=True).only(
        "id", "public_key", "json"
    )

    for xform in xform_qs.iterator(chunk_size=100):
        processed += 1
        print(f"processed {processed} xforms")

        if xform.encrypted:
            continue

        try:
            json_data = (
                json.loads(xform.json) if isinstance(xform.json, str) else xform.json
            )
            _ = create_survey_element_from_dict(json_data)
        except (KeyError, PyXFormError):
            json_data = (
                json.loads(xform.json) if isinstance(xform.json, str) else xform.json
            )
            process_children(json_data["children"], ensure_choices_exist(json_data))

            try:
                # Save back as JSON string
                xform.json = json.dumps(json_data)
                xform.save(update_fields=["json"])
            except (LimitExceededError, TypeError):
                pass
        except TypeError:
            pass
        except Exception as e:
            print(xform.pk, xform, e, type(e))
            break


class Migration(migrations.Migration):
    dependencies = [
        ("logger", "0030_rename_plaintext_to_unmanaged"),
    ]

    operations = [
        migrations.RunPython(update_xform_schema),
    ]
