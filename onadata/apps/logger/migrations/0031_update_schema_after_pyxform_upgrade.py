# Generated by Django 5.1.8 on 2025-08-15 06:33


import json
import logging

from django.db import migrations

from multidb.pinning import use_master
from pyxform.builder import create_survey_element_from_dict
from pyxform.errors import PyXFormError

SELECT_TYPES = ["select one", "select all that apply"]
CONTAINER_TYPES = ["group", "repeat"]
REQUIRED_FIELDS = ["name", "children"]


def ensure_choices_exist(data):
    """Ensure that the choices dictionary exists in the data."""
    if "choices" not in data:
        data["choices"] = {}
    return data["choices"]


def find_matching_choice_key(question_choices, choices):
    """Find a matching choice key for the given question choices."""
    # Create tuples of (name, label) for more precise matching
    question_choice_pairs = [
        (choice["name"], choice.get("label", "")) for choice in question_choices
    ]
    for choice_key, choice_list in choices.items():
        existing_choice_pairs = [
            (choice["name"], choice.get("label", "")) for choice in choice_list
        ]
        if question_choice_pairs == existing_choice_pairs:
            return choice_key
    return None


def process_select_question(child, choices):
    """Process a select question to add itemset attribute."""
    question_choices = child["children"]
    matching_key = find_matching_choice_key(question_choices, choices)
    if matching_key:
        # Use existing choice key
        child["itemset"] = matching_key
        logging.info(
            f"Question '{child['name']}' ({child['type']}) mapped to existing choice key '{matching_key}'"
        )
    else:
        # No matching choice found, add to choices using question name
        choices[child["name"]] = child["children"]
        child["itemset"] = child["name"]
        logging.info(
            f"Question '{child['name']}' ({child['type']}) added new choice key '{child['name']}'"
        )


def is_select_question_without_itemset(child):
    """Check if child is a select question without itemset."""
    return (
        child.get("type") in SELECT_TYPES
        and "children" in child
        and "itemset" not in child
    )


def is_container_with_children(child):
    """Check if child is a container (group/repeat) with children."""
    return child.get("type") in CONTAINER_TYPES and "children" in child


def process_children(children_list, choices):
    """Recursively process children to add itemset attributes"""
    for child in children_list:
        if is_select_question_without_itemset(child):
            process_select_question(child, choices)
        # Recursively process children in groups and repeats
        if is_container_with_children(child):
            process_children(child["children"], choices)


def update_xform_schema(apps, schema_editor):
    """Update the schema of all XForms after the PyXForm upgrade.

    This migration is necessary because the PyXForm upgrade introduced a bug
    that caused the schema of some XForms to be incorrect. This migration
    fixes the schema of all XForms after the PyXForm upgrade.
    """
    # Use live model for method get_survey_from_xlsform. This is needed because
    # apps.get_model("logger", "XForm") returns a frozen version of XForm
    # that has only the fields known at that migration
    from onadata.apps.logger.models.xform import XForm as LiveXForm

    XForm = apps.get_model("logger", "XForm")
    xform_qs = XForm.objects.filter(deleted_at__isnull=True, encrypted=False).only("id")
    processed = 0
    patched = 0

    with use_master():
        for xform in xform_qs.iterator(chunk_size=100):
            processed += 1
            print(f"processed {processed} xforms")

            try:
                json_data = (
                    json.loads(xform.json)
                    if isinstance(xform.json, str)
                    else xform.json
                )
                _ = create_survey_element_from_dict(json_data)

            except (KeyError, PyXFormError):
                try:
                    # Try to recreate the full schema from the xlsform
                    survey = LiveXForm.objects.get(
                        id=xform.id
                    ).get_survey_from_xlsform()
                    XForm.objects.filter(id=xform.id).update(json=survey.to_json_dict())

                except (KeyError, PyXFormError):
                    # If the full schema creation fails, try to patch the JSON
                    print(f"recreating XForm {xform.id} failed, perfoming patch")
                    process_children(
                        json_data["children"], ensure_choices_exist(json_data)
                    )
                    XForm.objects.filter(id=xform.id).update(json=json_data)
                    patched += 1

            except TypeError:
                pass

            except Exception as e:
                print(xform.pk, xform, e, type(e))
                break

    print(f"patched {patched} xforms")


class Migration(migrations.Migration):
    dependencies = [
        ("logger", "0030_rename_plaintext_to_unmanaged"),
    ]

    operations = [
        migrations.RunPython(
            update_xform_schema,
            reverse_code=migrations.RunPython.noop,  # migration is irreversible
        ),
    ]
